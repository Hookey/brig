// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

// Commit is a set of changes to nodes
type Commit struct{ capnp.Struct }
type Commit_merge Commit

// Commit_TypeID is the unique identifier for the type Commit.
const Commit_TypeID = 0x8da013c66e545daf

func NewCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func NewRootCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func ReadRootCommit(msg *capnp.Message) (Commit, error) {
	root, err := msg.RootPtr()
	return Commit{root.Struct()}, err
}

func (s Commit) String() string {
	str, _ := text.Marshal(0x8da013c66e545daf, s.Struct)
	return str
}

func (s Commit) Message() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Commit) HasMessage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Commit) MessageBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Commit) SetMessage(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Commit) Author() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s Commit) HasAuthor() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Commit) AuthorBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s Commit) SetAuthor(v string) error {
	return s.Struct.SetText(1, v)
}

func (s Commit) Parent() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return []byte(p.Data()), err
}

func (s Commit) HasParent() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Commit) SetParent(v []byte) error {
	return s.Struct.SetData(2, v)
}

func (s Commit) Root() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Commit) HasRoot() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Commit) SetRoot(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Commit) Index() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Commit) SetIndex(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Commit) Merge() Commit_merge { return Commit_merge(s) }

func (s Commit_merge) With() (string, error) {
	p, err := s.Struct.Ptr(4)
	return p.Text(), err
}

func (s Commit_merge) HasWith() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Commit_merge) WithBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return p.TextBytes(), err
}

func (s Commit_merge) SetWith(v string) error {
	return s.Struct.SetText(4, v)
}

func (s Commit_merge) Head() ([]byte, error) {
	p, err := s.Struct.Ptr(5)
	return []byte(p.Data()), err
}

func (s Commit_merge) HasHead() bool {
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Commit_merge) SetHead(v []byte) error {
	return s.Struct.SetData(5, v)
}

// Commit_List is a list of Commit.
type Commit_List struct{ capnp.List }

// NewCommit creates a new list of Commit.
func NewCommit_List(s *capnp.Segment, sz int32) (Commit_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return Commit_List{l}, err
}

func (s Commit_List) At(i int) Commit { return Commit{s.List.Struct(i)} }

func (s Commit_List) Set(i int, v Commit) error { return s.List.SetStruct(i, v.Struct) }

func (s Commit_List) String() string {
	str, _ := text.MarshalList(0x8da013c66e545daf, s.List)
	return str
}

// Commit_Promise is a wrapper for a Commit promised by a client call.
type Commit_Promise struct{ *capnp.Pipeline }

func (p Commit_Promise) Struct() (Commit, error) {
	s, err := p.Pipeline.Struct()
	return Commit{s}, err
}

func (p Commit_Promise) Merge() Commit_merge_Promise { return Commit_merge_Promise{p.Pipeline} }

// Commit_merge_Promise is a wrapper for a Commit_merge promised by a client call.
type Commit_merge_Promise struct{ *capnp.Pipeline }

func (p Commit_merge_Promise) Struct() (Commit_merge, error) {
	s, err := p.Pipeline.Struct()
	return Commit_merge{s}, err
}

// A single directory entry
type DirEntry struct{ capnp.Struct }

// DirEntry_TypeID is the unique identifier for the type DirEntry.
const DirEntry_TypeID = 0x8b15ee76774b1f9d

func NewDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func NewRootDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func ReadRootDirEntry(msg *capnp.Message) (DirEntry, error) {
	root, err := msg.RootPtr()
	return DirEntry{root.Struct()}, err
}

func (s DirEntry) String() string {
	str, _ := text.Marshal(0x8b15ee76774b1f9d, s.Struct)
	return str
}

func (s DirEntry) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s DirEntry) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DirEntry) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s DirEntry) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s DirEntry) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s DirEntry) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DirEntry) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

// DirEntry_List is a list of DirEntry.
type DirEntry_List struct{ capnp.List }

// NewDirEntry creates a new list of DirEntry.
func NewDirEntry_List(s *capnp.Segment, sz int32) (DirEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DirEntry_List{l}, err
}

func (s DirEntry_List) At(i int) DirEntry { return DirEntry{s.List.Struct(i)} }

func (s DirEntry_List) Set(i int, v DirEntry) error { return s.List.SetStruct(i, v.Struct) }

func (s DirEntry_List) String() string {
	str, _ := text.MarshalList(0x8b15ee76774b1f9d, s.List)
	return str
}

// DirEntry_Promise is a wrapper for a DirEntry promised by a client call.
type DirEntry_Promise struct{ *capnp.Pipeline }

func (p DirEntry_Promise) Struct() (DirEntry, error) {
	s, err := p.Pipeline.Struct()
	return DirEntry{s}, err
}

// Directory contains one or more directories or files
type Directory struct{ capnp.Struct }

// Directory_TypeID is the unique identifier for the type Directory.
const Directory_TypeID = 0xe24c59306c829c01

func NewDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Directory{st}, err
}

func NewRootDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Directory{st}, err
}

func ReadRootDirectory(msg *capnp.Message) (Directory, error) {
	root, err := msg.RootPtr()
	return Directory{root.Struct()}, err
}

func (s Directory) String() string {
	str, _ := text.Marshal(0xe24c59306c829c01, s.Struct)
	return str
}

func (s Directory) Size() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Directory) SetSize(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Directory) CachedSize() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s Directory) SetCachedSize(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

func (s Directory) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Directory) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Directory) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Directory) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Directory) Children() (DirEntry_List, error) {
	p, err := s.Struct.Ptr(1)
	return DirEntry_List{List: p.List()}, err
}

func (s Directory) HasChildren() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Directory) SetChildren(v DirEntry_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewChildren(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(s.Struct.Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s Directory) Contents() (DirEntry_List, error) {
	p, err := s.Struct.Ptr(2)
	return DirEntry_List{List: p.List()}, err
}

func (s Directory) HasContents() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Directory) SetContents(v DirEntry_List) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewContents sets the contents field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewContents(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(s.Struct.Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

// Directory_List is a list of Directory.
type Directory_List struct{ capnp.List }

// NewDirectory creates a new list of Directory.
func NewDirectory_List(s *capnp.Segment, sz int32) (Directory_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3}, sz)
	return Directory_List{l}, err
}

func (s Directory_List) At(i int) Directory { return Directory{s.List.Struct(i)} }

func (s Directory_List) Set(i int, v Directory) error { return s.List.SetStruct(i, v.Struct) }

func (s Directory_List) String() string {
	str, _ := text.MarshalList(0xe24c59306c829c01, s.List)
	return str
}

// Directory_Promise is a wrapper for a Directory promised by a client call.
type Directory_Promise struct{ *capnp.Pipeline }

func (p Directory_Promise) Struct() (Directory, error) {
	s, err := p.Pipeline.Struct()
	return Directory{s}, err
}

// A leaf node in the MDAG
type File struct{ capnp.Struct }

// File_TypeID is the unique identifier for the type File.
const File_TypeID = 0x8ea7393d37893155

func NewFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return File{st}, err
}

func NewRootFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return File{st}, err
}

func ReadRootFile(msg *capnp.Message) (File, error) {
	root, err := msg.RootPtr()
	return File{root.Struct()}, err
}

func (s File) String() string {
	str, _ := text.Marshal(0x8ea7393d37893155, s.Struct)
	return str
}

func (s File) Size() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s File) SetSize(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s File) CachedSize() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s File) SetCachedSize(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

func (s File) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s File) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s File) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s File) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s File) Key() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s File) HasKey() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s File) SetKey(v []byte) error {
	return s.Struct.SetData(1, v)
}

// File_List is a list of File.
type File_List struct{ capnp.List }

// NewFile creates a new list of File.
func NewFile_List(s *capnp.Segment, sz int32) (File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return File_List{l}, err
}

func (s File_List) At(i int) File { return File{s.List.Struct(i)} }

func (s File_List) Set(i int, v File) error { return s.List.SetStruct(i, v.Struct) }

func (s File_List) String() string {
	str, _ := text.MarshalList(0x8ea7393d37893155, s.List)
	return str
}

// File_Promise is a wrapper for a File promised by a client call.
type File_Promise struct{ *capnp.Pipeline }

func (p File_Promise) Struct() (File, error) {
	s, err := p.Pipeline.Struct()
	return File{s}, err
}

// Ghost indicates that a certain node was at this path once
type Ghost struct{ capnp.Struct }
type Ghost_Which uint16

const (
	Ghost_Which_commit    Ghost_Which = 0
	Ghost_Which_directory Ghost_Which = 1
	Ghost_Which_file      Ghost_Which = 2
)

func (w Ghost_Which) String() string {
	const s = "commitdirectoryfile"
	switch w {
	case Ghost_Which_commit:
		return s[0:6]
	case Ghost_Which_directory:
		return s[6:15]
	case Ghost_Which_file:
		return s[15:19]

	}
	return "Ghost_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Ghost_TypeID is the unique identifier for the type Ghost.
const Ghost_TypeID = 0x80c828d7e89c12ea

func NewGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Ghost{st}, err
}

func NewRootGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Ghost{st}, err
}

func ReadRootGhost(msg *capnp.Message) (Ghost, error) {
	root, err := msg.RootPtr()
	return Ghost{root.Struct()}, err
}

func (s Ghost) String() string {
	str, _ := text.Marshal(0x80c828d7e89c12ea, s.Struct)
	return str
}

func (s Ghost) Which() Ghost_Which {
	return Ghost_Which(s.Struct.Uint16(8))
}
func (s Ghost) GhostInode() uint64 {
	return s.Struct.Uint64(0)
}

func (s Ghost) SetGhostInode(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Ghost) GhostPath() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Ghost) HasGhostPath() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Ghost) GhostPathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Ghost) SetGhostPath(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Ghost) Commit() (Commit, error) {
	if s.Struct.Uint16(8) != 0 {
		panic("Which() != commit")
	}
	p, err := s.Struct.Ptr(1)
	return Commit{Struct: p.Struct()}, err
}

func (s Ghost) HasCommit() bool {
	if s.Struct.Uint16(8) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Ghost) SetCommit(v Commit) error {
	s.Struct.SetUint16(8, 0)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Ghost) NewCommit() (Commit, error) {
	s.Struct.SetUint16(8, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Ghost) Directory() (Directory, error) {
	if s.Struct.Uint16(8) != 1 {
		panic("Which() != directory")
	}
	p, err := s.Struct.Ptr(1)
	return Directory{Struct: p.Struct()}, err
}

func (s Ghost) HasDirectory() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Ghost) SetDirectory(v Directory) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Ghost) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Ghost) File() (File, error) {
	if s.Struct.Uint16(8) != 2 {
		panic("Which() != file")
	}
	p, err := s.Struct.Ptr(1)
	return File{Struct: p.Struct()}, err
}

func (s Ghost) HasFile() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Ghost) SetFile(v File) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Ghost) NewFile() (File, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Ghost_List is a list of Ghost.
type Ghost_List struct{ capnp.List }

// NewGhost creates a new list of Ghost.
func NewGhost_List(s *capnp.Segment, sz int32) (Ghost_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return Ghost_List{l}, err
}

func (s Ghost_List) At(i int) Ghost { return Ghost{s.List.Struct(i)} }

func (s Ghost_List) Set(i int, v Ghost) error { return s.List.SetStruct(i, v.Struct) }

func (s Ghost_List) String() string {
	str, _ := text.MarshalList(0x80c828d7e89c12ea, s.List)
	return str
}

// Ghost_Promise is a wrapper for a Ghost promised by a client call.
type Ghost_Promise struct{ *capnp.Pipeline }

func (p Ghost_Promise) Struct() (Ghost, error) {
	s, err := p.Pipeline.Struct()
	return Ghost{s}, err
}

func (p Ghost_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Ghost_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Ghost_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

// Node is a node in the merkle dag of brig
type Node struct{ capnp.Struct }
type Node_Which uint16

const (
	Node_Which_commit    Node_Which = 0
	Node_Which_directory Node_Which = 1
	Node_Which_file      Node_Which = 2
	Node_Which_ghost     Node_Which = 3
)

func (w Node_Which) String() string {
	const s = "commitdirectoryfileghost"
	switch w {
	case Node_Which_commit:
		return s[0:6]
	case Node_Which_directory:
		return s[6:15]
	case Node_Which_file:
		return s[15:19]
	case Node_Which_ghost:
		return s[19:24]

	}
	return "Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xa629eb7f7066fae3

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Node{st}, err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Node{st}, err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.RootPtr()
	return Node{root.Struct()}, err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xa629eb7f7066fae3, s.Struct)
	return str
}

func (s Node) Which() Node_Which {
	return Node_Which(s.Struct.Uint16(8))
}
func (s Node) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Node) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Node) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Node) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Node) TreeHash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Node) HasTreeHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Node) SetTreeHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

func (s Node) ModTime() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s Node) HasModTime() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Node) ModTimeBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s Node) SetModTime(v string) error {
	return s.Struct.SetText(2, v)
}

func (s Node) Inode() uint64 {
	return s.Struct.Uint64(0)
}

func (s Node) SetInode(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Node) ContentHash() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Node) HasContentHash() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetContentHash(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Node) User() (string, error) {
	p, err := s.Struct.Ptr(4)
	return p.Text(), err
}

func (s Node) HasUser() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Node) UserBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return p.TextBytes(), err
}

func (s Node) SetUser(v string) error {
	return s.Struct.SetText(4, v)
}

func (s Node) Commit() (Commit, error) {
	if s.Struct.Uint16(8) != 0 {
		panic("Which() != commit")
	}
	p, err := s.Struct.Ptr(5)
	return Commit{Struct: p.Struct()}, err
}

func (s Node) HasCommit() bool {
	if s.Struct.Uint16(8) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetCommit(v Commit) error {
	s.Struct.SetUint16(8, 0)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Node) NewCommit() (Commit, error) {
	s.Struct.SetUint16(8, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Directory() (Directory, error) {
	if s.Struct.Uint16(8) != 1 {
		panic("Which() != directory")
	}
	p, err := s.Struct.Ptr(5)
	return Directory{Struct: p.Struct()}, err
}

func (s Node) HasDirectory() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetDirectory(v Directory) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Node) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) File() (File, error) {
	if s.Struct.Uint16(8) != 2 {
		panic("Which() != file")
	}
	p, err := s.Struct.Ptr(5)
	return File{Struct: p.Struct()}, err
}

func (s Node) HasFile() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetFile(v File) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Node) NewFile() (File, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Ghost() (Ghost, error) {
	if s.Struct.Uint16(8) != 3 {
		panic("Which() != ghost")
	}
	p, err := s.Struct.Ptr(5)
	return Ghost{Struct: p.Struct()}, err
}

func (s Node) HasGhost() bool {
	if s.Struct.Uint16(8) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetGhost(v Ghost) error {
	s.Struct.SetUint16(8, 3)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewGhost sets the ghost field to a newly
// allocated Ghost struct, preferring placement in s's segment.
func (s Node) NewGhost() (Ghost, error) {
	s.Struct.SetUint16(8, 3)
	ss, err := NewGhost(s.Struct.Segment())
	if err != nil {
		return Ghost{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) BackendHash() ([]byte, error) {
	p, err := s.Struct.Ptr(6)
	return []byte(p.Data()), err
}

func (s Node) HasBackendHash() bool {
	p, err := s.Struct.Ptr(6)
	return p.IsValid() || err != nil
}

func (s Node) SetBackendHash(v []byte) error {
	return s.Struct.SetData(6, v)
}

// Node_List is a list of Node.
type Node_List struct{ capnp.List }

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7}, sz)
	return Node_List{l}, err
}

func (s Node_List) At(i int) Node { return Node{s.List.Struct(i)} }

func (s Node_List) Set(i int, v Node) error { return s.List.SetStruct(i, v.Struct) }

func (s Node_List) String() string {
	str, _ := text.MarshalList(0xa629eb7f7066fae3, s.List)
	return str
}

// Node_Promise is a wrapper for a Node promised by a client call.
type Node_Promise struct{ *capnp.Pipeline }

func (p Node_Promise) Struct() (Node, error) {
	s, err := p.Pipeline.Struct()
	return Node{s}, err
}

func (p Node_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

func (p Node_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

func (p Node_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

func (p Node_Promise) Ghost() Ghost_Promise {
	return Ghost_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

const schema_9195d073cb5c5953 = "x\xda\xb4V_hTW\x1e\xfe}\xe7\xdc\xc9\x9dH" +
	"\xdc\x99\xd9\x93\x80\x0f\x869\x88B\x94\xac$\xc6e5" +
	"\xb8h4Yc6+9\x8e\xb2\xba\xb8\x0b\xd7\x99\x93" +
	"\xdc\x8b3\xf7f\xef\xbd6\xa64h\x8b\x01\xb5Z\xb4" +
	"\xb5PK\xa4Zb[KK\xff\xbc\xf5\xa1\xb4\x14Z" +
	"\x8a})}h\xa1\x0f\x85\xfe\x81\x96\x16\xfa\\J\xf5" +
	"\x963\x7f\x93\x10\xfbP\xe8\xe3|\xbfs\xcf\xfd~\xdf" +
	"\xef\xfb}w\xfa\xbe`{X\x7f*`Dj}\xaa" +
	"-\xf9\xfe\xcf\x0b\xdf}\xd6\xf3\xe1YR\x1d`I\xe1" +
	"\xd8\xf1\x8f\xa2\x8f\x9f\xbeJ#\xcc\xe6\xb0D7\x9e\x14" +
	"\x9b`\x8bM\xc8\x0f8\xc8\x83\x90\xdc\xc8\xffs\xe6\xa1" +
	"\x1f\xbb\x1e\xa7\\\x07Z\xe7S\xcc&\x12s\xece1" +
	"\xcfl1\xcf\xf2\xe2\x0d6CH^\xfb\xefa\xff\x03" +
	"q\xf3\xb2\xb9~\xe9\xf16s|-\x7fVtq[" +
	"t\xf1\xfc\xc0\x08\xff\xb7\xb9\xfdH\xff\x85\xbf\xfd}\xe7" +
	"\x8bO\xac\xa0S\xbb\xfe\x94uQ\xccY\xb6\x98\xb3\xf2" +
	"\xe2\xb6\xf5-!\xf9\xfa\xe7\xc9\xe93?l~a%" +
	"{\xdb\xb6`\x89\xb9\xd4E1\x9f\xb2\xc5|*?\xf0" +
	"\x96i\x19\xc9\xe27\xe3\x9fg\x16\x7fz\x87\x94\xc0\x12" +
	"v]m6\x88\xc4P\xfa.A\x8c\xa4\x0ds,<" +
	"V\xee;6\xfe\xd5J&\xdc0\xb9\x95~S\xdcI" +
	"\xdb\xe2N:?\xf0e\xba\xaa\x8b\x1f\x94t\xb4\xb5\xe8" +
	"`\xda\x9f\x1e\xdc\xef\x06\x11\xe2\x09@Y`\xc9\xff\x9e" +
	"zN\xbd\xfd\xe9\xc5\xf7IY\x0cC\xbd@\x07Q?" +
	">Ab\x8e\xc5\xd2\xf3\xdbJ^\xd1\x89u$c\xd7" +
	"\x89\xa5#\x8b:\x8c\x1d\xcf\x97\xe6N9\xe3D\xd2\x89" +
	"e\xecz\x91\x9cvbW\x06~\x11\x9aHur\x8b" +
	"\xc8\x02Qn\xee?D\xea\x11\x0eu\x9e\x01\xe8\x84\xc1" +
	"\xe6\x0f\x11\xa9s\x1c\xea\x0aC7K\x12t\x82\x11\xe5" +
	".\x0f\x12\xa9\xf3\x1c\xea\x1aC7\xbfo`N\x94\xbb" +
	"jN_\xe1P\x0b\x0c\xdd\xd6=\x03[D\xb9\xeb[" +
	"\x88\xd45\x0eu\x93!\x992l\x0f\xf8\x01\xf1\x92F" +
	";1\xb4S\x1d\x9cpb\x82\x8b\x0eb\xe8 \xec." +
	"\x06\x95\x8a\x17#\xdb\xd2\x97\x80,!)y\xa1.\xc6" +
	"AH\x98E\xb6\xa5p\xad\x9a\x99\xf4\xca\x1a\xd9\x96\x05" +
	"\xea\x0f-\x13v\xd8\x0bG2~\x1c\xce\xae\xae\xed\xfa" +
	"\xaa\xb69\xdcM\x86d\xe4\xf9Se\xcdd\xe3\xa5\xb3" +
	"R\x9b\x07\x09*\xdd\x14n\xb3\xe9o#\x87\xeac\xc8" +
	"5\x94\xfb\x8b\x01{8\xd4v\x86\x8c\xefTt\xa3\xb1" +
	"\x8c\xebD.\xd6\x12\xc3\xda\x95\xbc\xf6\x05\x95\x0a\xf7\x1e" +
	"0qY\x9f\xf8\x06$\xfb\xaa\xd2H\x8fG\xd2\x91\x91" +
	"\x8ee0)\x8b\xae\xe3O\x99\xe1\x07\xd2\x0f\xec\x92\x8e" +
	"\x88\xd4\xba&\xc5\xeb{[#hR\xbca\xa6\xf8\x0c" +
	"\x87Zd\xc81V\x1b\xed-\x03.p\xa8\x97\x18r" +
	"\x9c\xd7\x06{\xdb4s\x93C\xbd\xc2\x00\xab6\xd5;" +
	"\xdb\x88\xd4\"\x87z\x9d\x01),\xd9\x8a\xdc\xab\xdb\x88" +
	"\x9d\xa9\xe8(r\xa6\x9am\xefvN\xc5n\x106\x7f" +
	"N;\xa1\xf6\xe3\x86\x0e\x990\x08\x9a?\xf2\x9e_\xd2" +
	"\xa7\x91\"\x86\x14!_\xd1\xe1\x94^.\xd4?\xbc\xb2" +
	"&Z]\xa7u\xf5\xe9\xbd\x97\x0c\xc9\xb2v&\xa5\xcf" +
	"\xcc\x02x\xbe\x8c]-\xff5<\xb4\x9f\x88T\xb6)" +
	"\x8dcz;\xce\xa1\xdc%\xd2h\xb3\x0b%\x0e5\xcd" +
	"\x80\xba2\x15\xa3\x8c\xcb\xa1b\xa3L\xdd\xf2\xff\xdf@" +
	"\xa4\xca\x1c\xea4C&\xf2\x1e\xd6\x0d\xdaI\xd1)\xba" +
	"\xbaT\xf0\x88\xb7\xc0F\xd7u\x11\xec\x93zvu'" +
	"\x1c\x0cJ\x0flpc\xdd\x08cH\x0eV;\x8b\xa4" +
	"\xe5\xd4\xb6\xbc\xdedE\x87'\xcbZ\x96\x9c)\xe3\x8c" +
	"\x13\xa17EP\xbd\x8d\x8e\xc5&l!*Hp\x14" +
	"z\xd1jZl\xc6\x18Q\xa1\xc7\xe0\xdb\xd1\xb2\x84\xe8" +
	"\xc7^\xa2B\xaf\xc1w\x80\x015S\x88\xbfb\x1bQ" +
	"\xa1\xcf\xc0\xbb\xccq\x8bW\x8d!v\xe2\x04Qa\x87" +
	"\xc1\x87\x0d\x9e\xb2:\x912\xb9X}\xed.\x83\x8f\x82" +
	"\xa1\xbb-IR\x9dh#\x12#\x18$*\xec1\x95" +
	"qS\xb1\xef\x9b\x8a\x89\xc8\x038DT\x185\x95\xc3" +
	"\xa6\x92\xbeg*i\"\xa1\xaa\xb7\x8d\x9b\xcaQSi" +
	"\xff\xc5T\xda\x89\xc4\x91*\xaf\x09S9n\xde\xbf\xa6" +
	"\xad\x13k\x88\xc4\xb1*\xaf\xa3\x06/a\xc5R&q" +
	"\xa8\xf5\xa8\x13\xb9D\xd4\x98\xc8\x99JP:\xec\xb5\xce" +
	"\xe4=\xa3q3\xb3\x8a\x81\x1fk?\x1e%{\xc9>" +
	"gNE:\xfcc\",_\x0dId[\x1f\xdb\xfa" +
	"e'\x9c\xe2I\xed\x97\x96\x13i\xda\x895\x82\xc5\x8b" +
	"\xb7V7\x89\xc8DW\xb66\x94\x15\xd9U\x9b\xc7\xf2" +
	"\xec\x9a\xf1b\xb7\x95]\xda)\xad\xee\xd8a/\xd4\xf9" +
	"jB\xae\xee\xda\x9e\xbak\x9fG2\\\xef>5+" +
	"\x8d\x88\x8e\xe7G2\xf0\xb5\x0cBY\x09B\xdd\xccZ" +
	"OG\x06\x9b\xf4\xecr5\xce\x96|\xaa\x0c\xc1\xd3\x1c" +
	"\xea\xdc\x92\x9d}\xd4\xec\xecY\x0eu\xa9\xb5\xb3\x17\x06" +
	"[\xdf\xaf\xe6\xce^\x1e#R\x97\xea\x11g\xb1Z\x9c" +
	"\xdd\x1e\xab\xc7\xd9\xbb\xbfc\x91\x93\xa2\xeb\x95K\xa1\xf6" +
	"\x8d}\xfeD\x98\xe0@\xb6\xf5'\x87`\xc0\x86c\xa2" +
	"\xdf:\xf4k\x00\x00\x00\xff\xff+n%\xb3"

func init() {
	schemas.Register(schema_9195d073cb5c5953,
		0x80c828d7e89c12ea,
		0x8b15ee76774b1f9d,
		0x8da013c66e545daf,
		0x8ea7393d37893155,
		0xa629eb7f7066fae3,
		0xbff8a40fda4ce4a4,
		0xe24c59306c829c01)
}
