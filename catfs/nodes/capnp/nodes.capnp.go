// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

// Commit is a set of changes to nodes
type Commit struct{ capnp.Struct }
type Commit_merge Commit

// Commit_TypeID is the unique identifier for the type Commit.
const Commit_TypeID = 0x8da013c66e545daf

func NewCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func NewRootCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func ReadRootCommit(msg *capnp.Message) (Commit, error) {
	root, err := msg.RootPtr()
	return Commit{root.Struct()}, err
}

func (s Commit) String() string {
	str, _ := text.Marshal(0x8da013c66e545daf, s.Struct)
	return str
}

func (s Commit) Message() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Commit) HasMessage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Commit) MessageBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Commit) SetMessage(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Commit) Author() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s Commit) HasAuthor() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Commit) AuthorBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s Commit) SetAuthor(v string) error {
	return s.Struct.SetText(1, v)
}

func (s Commit) Parent() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return []byte(p.Data()), err
}

func (s Commit) HasParent() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Commit) SetParent(v []byte) error {
	return s.Struct.SetData(2, v)
}

func (s Commit) Root() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Commit) HasRoot() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Commit) SetRoot(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Commit) Index() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Commit) SetIndex(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Commit) Merge() Commit_merge { return Commit_merge(s) }

func (s Commit_merge) With() (string, error) {
	p, err := s.Struct.Ptr(4)
	return p.Text(), err
}

func (s Commit_merge) HasWith() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Commit_merge) WithBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return p.TextBytes(), err
}

func (s Commit_merge) SetWith(v string) error {
	return s.Struct.SetText(4, v)
}

func (s Commit_merge) Head() ([]byte, error) {
	p, err := s.Struct.Ptr(5)
	return []byte(p.Data()), err
}

func (s Commit_merge) HasHead() bool {
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Commit_merge) SetHead(v []byte) error {
	return s.Struct.SetData(5, v)
}

// Commit_List is a list of Commit.
type Commit_List struct{ capnp.List }

// NewCommit creates a new list of Commit.
func NewCommit_List(s *capnp.Segment, sz int32) (Commit_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return Commit_List{l}, err
}

func (s Commit_List) At(i int) Commit { return Commit{s.List.Struct(i)} }

func (s Commit_List) Set(i int, v Commit) error { return s.List.SetStruct(i, v.Struct) }

func (s Commit_List) String() string {
	str, _ := text.MarshalList(0x8da013c66e545daf, s.List)
	return str
}

// Commit_Promise is a wrapper for a Commit promised by a client call.
type Commit_Promise struct{ *capnp.Pipeline }

func (p Commit_Promise) Struct() (Commit, error) {
	s, err := p.Pipeline.Struct()
	return Commit{s}, err
}

func (p Commit_Promise) Merge() Commit_merge_Promise { return Commit_merge_Promise{p.Pipeline} }

// Commit_merge_Promise is a wrapper for a Commit_merge promised by a client call.
type Commit_merge_Promise struct{ *capnp.Pipeline }

func (p Commit_merge_Promise) Struct() (Commit_merge, error) {
	s, err := p.Pipeline.Struct()
	return Commit_merge{s}, err
}

// A single directory entry
type DirEntry struct{ capnp.Struct }

// DirEntry_TypeID is the unique identifier for the type DirEntry.
const DirEntry_TypeID = 0x8b15ee76774b1f9d

func NewDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func NewRootDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func ReadRootDirEntry(msg *capnp.Message) (DirEntry, error) {
	root, err := msg.RootPtr()
	return DirEntry{root.Struct()}, err
}

func (s DirEntry) String() string {
	str, _ := text.Marshal(0x8b15ee76774b1f9d, s.Struct)
	return str
}

func (s DirEntry) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s DirEntry) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DirEntry) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s DirEntry) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s DirEntry) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s DirEntry) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DirEntry) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

// DirEntry_List is a list of DirEntry.
type DirEntry_List struct{ capnp.List }

// NewDirEntry creates a new list of DirEntry.
func NewDirEntry_List(s *capnp.Segment, sz int32) (DirEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DirEntry_List{l}, err
}

func (s DirEntry_List) At(i int) DirEntry { return DirEntry{s.List.Struct(i)} }

func (s DirEntry_List) Set(i int, v DirEntry) error { return s.List.SetStruct(i, v.Struct) }

func (s DirEntry_List) String() string {
	str, _ := text.MarshalList(0x8b15ee76774b1f9d, s.List)
	return str
}

// DirEntry_Promise is a wrapper for a DirEntry promised by a client call.
type DirEntry_Promise struct{ *capnp.Pipeline }

func (p DirEntry_Promise) Struct() (DirEntry, error) {
	s, err := p.Pipeline.Struct()
	return DirEntry{s}, err
}

// Directory contains one or more directories or files
type Directory struct{ capnp.Struct }

// Directory_TypeID is the unique identifier for the type Directory.
const Directory_TypeID = 0xe24c59306c829c01

func NewDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Directory{st}, err
}

func NewRootDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Directory{st}, err
}

func ReadRootDirectory(msg *capnp.Message) (Directory, error) {
	root, err := msg.RootPtr()
	return Directory{root.Struct()}, err
}

func (s Directory) String() string {
	str, _ := text.Marshal(0xe24c59306c829c01, s.Struct)
	return str
}

func (s Directory) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s Directory) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Directory) CachedSize() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s Directory) SetCachedSize(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

func (s Directory) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Directory) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Directory) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Directory) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Directory) Children() (DirEntry_List, error) {
	p, err := s.Struct.Ptr(1)
	return DirEntry_List{List: p.List()}, err
}

func (s Directory) HasChildren() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Directory) SetChildren(v DirEntry_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewChildren(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(s.Struct.Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s Directory) Contents() (DirEntry_List, error) {
	p, err := s.Struct.Ptr(2)
	return DirEntry_List{List: p.List()}, err
}

func (s Directory) HasContents() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Directory) SetContents(v DirEntry_List) error {
	return s.Struct.SetPtr(2, v.List.ToPtr())
}

// NewContents sets the contents field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewContents(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(s.Struct.Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = s.Struct.SetPtr(2, l.List.ToPtr())
	return l, err
}

// Directory_List is a list of Directory.
type Directory_List struct{ capnp.List }

// NewDirectory creates a new list of Directory.
func NewDirectory_List(s *capnp.Segment, sz int32) (Directory_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3}, sz)
	return Directory_List{l}, err
}

func (s Directory_List) At(i int) Directory { return Directory{s.List.Struct(i)} }

func (s Directory_List) Set(i int, v Directory) error { return s.List.SetStruct(i, v.Struct) }

func (s Directory_List) String() string {
	str, _ := text.MarshalList(0xe24c59306c829c01, s.List)
	return str
}

// Directory_Promise is a wrapper for a Directory promised by a client call.
type Directory_Promise struct{ *capnp.Pipeline }

func (p Directory_Promise) Struct() (Directory, error) {
	s, err := p.Pipeline.Struct()
	return Directory{s}, err
}

// A leaf node in the MDAG
type File struct{ capnp.Struct }

// File_TypeID is the unique identifier for the type File.
const File_TypeID = 0x8ea7393d37893155

func NewFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return File{st}, err
}

func NewRootFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return File{st}, err
}

func ReadRootFile(msg *capnp.Message) (File, error) {
	root, err := msg.RootPtr()
	return File{root.Struct()}, err
}

func (s File) String() string {
	str, _ := text.Marshal(0x8ea7393d37893155, s.Struct)
	return str
}

func (s File) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s File) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s File) CachedSize() int64 {
	return int64(s.Struct.Uint64(8))
}

func (s File) SetCachedSize(v int64) {
	s.Struct.SetUint64(8, uint64(v))
}

func (s File) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s File) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s File) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s File) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s File) Key() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s File) HasKey() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s File) SetKey(v []byte) error {
	return s.Struct.SetData(1, v)
}

// File_List is a list of File.
type File_List struct{ capnp.List }

// NewFile creates a new list of File.
func NewFile_List(s *capnp.Segment, sz int32) (File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return File_List{l}, err
}

func (s File_List) At(i int) File { return File{s.List.Struct(i)} }

func (s File_List) Set(i int, v File) error { return s.List.SetStruct(i, v.Struct) }

func (s File_List) String() string {
	str, _ := text.MarshalList(0x8ea7393d37893155, s.List)
	return str
}

// File_Promise is a wrapper for a File promised by a client call.
type File_Promise struct{ *capnp.Pipeline }

func (p File_Promise) Struct() (File, error) {
	s, err := p.Pipeline.Struct()
	return File{s}, err
}

// Ghost indicates that a certain node was at this path once
type Ghost struct{ capnp.Struct }
type Ghost_Which uint16

const (
	Ghost_Which_commit    Ghost_Which = 0
	Ghost_Which_directory Ghost_Which = 1
	Ghost_Which_file      Ghost_Which = 2
)

func (w Ghost_Which) String() string {
	const s = "commitdirectoryfile"
	switch w {
	case Ghost_Which_commit:
		return s[0:6]
	case Ghost_Which_directory:
		return s[6:15]
	case Ghost_Which_file:
		return s[15:19]

	}
	return "Ghost_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Ghost_TypeID is the unique identifier for the type Ghost.
const Ghost_TypeID = 0x80c828d7e89c12ea

func NewGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Ghost{st}, err
}

func NewRootGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Ghost{st}, err
}

func ReadRootGhost(msg *capnp.Message) (Ghost, error) {
	root, err := msg.RootPtr()
	return Ghost{root.Struct()}, err
}

func (s Ghost) String() string {
	str, _ := text.Marshal(0x80c828d7e89c12ea, s.Struct)
	return str
}

func (s Ghost) Which() Ghost_Which {
	return Ghost_Which(s.Struct.Uint16(8))
}
func (s Ghost) GhostInode() uint64 {
	return s.Struct.Uint64(0)
}

func (s Ghost) SetGhostInode(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Ghost) GhostPath() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Ghost) HasGhostPath() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Ghost) GhostPathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Ghost) SetGhostPath(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Ghost) Commit() (Commit, error) {
	if s.Struct.Uint16(8) != 0 {
		panic("Which() != commit")
	}
	p, err := s.Struct.Ptr(1)
	return Commit{Struct: p.Struct()}, err
}

func (s Ghost) HasCommit() bool {
	if s.Struct.Uint16(8) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Ghost) SetCommit(v Commit) error {
	s.Struct.SetUint16(8, 0)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Ghost) NewCommit() (Commit, error) {
	s.Struct.SetUint16(8, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Ghost) Directory() (Directory, error) {
	if s.Struct.Uint16(8) != 1 {
		panic("Which() != directory")
	}
	p, err := s.Struct.Ptr(1)
	return Directory{Struct: p.Struct()}, err
}

func (s Ghost) HasDirectory() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Ghost) SetDirectory(v Directory) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Ghost) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Ghost) File() (File, error) {
	if s.Struct.Uint16(8) != 2 {
		panic("Which() != file")
	}
	p, err := s.Struct.Ptr(1)
	return File{Struct: p.Struct()}, err
}

func (s Ghost) HasFile() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Ghost) SetFile(v File) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Ghost) NewFile() (File, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Ghost_List is a list of Ghost.
type Ghost_List struct{ capnp.List }

// NewGhost creates a new list of Ghost.
func NewGhost_List(s *capnp.Segment, sz int32) (Ghost_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return Ghost_List{l}, err
}

func (s Ghost_List) At(i int) Ghost { return Ghost{s.List.Struct(i)} }

func (s Ghost_List) Set(i int, v Ghost) error { return s.List.SetStruct(i, v.Struct) }

func (s Ghost_List) String() string {
	str, _ := text.MarshalList(0x80c828d7e89c12ea, s.List)
	return str
}

// Ghost_Promise is a wrapper for a Ghost promised by a client call.
type Ghost_Promise struct{ *capnp.Pipeline }

func (p Ghost_Promise) Struct() (Ghost, error) {
	s, err := p.Pipeline.Struct()
	return Ghost{s}, err
}

func (p Ghost_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Ghost_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Ghost_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

// Node is a node in the merkle dag of brig
type Node struct{ capnp.Struct }
type Node_Which uint16

const (
	Node_Which_commit    Node_Which = 0
	Node_Which_directory Node_Which = 1
	Node_Which_file      Node_Which = 2
	Node_Which_ghost     Node_Which = 3
)

func (w Node_Which) String() string {
	const s = "commitdirectoryfileghost"
	switch w {
	case Node_Which_commit:
		return s[0:6]
	case Node_Which_directory:
		return s[6:15]
	case Node_Which_file:
		return s[15:19]
	case Node_Which_ghost:
		return s[19:24]

	}
	return "Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xa629eb7f7066fae3

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Node{st}, err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Node{st}, err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.RootPtr()
	return Node{root.Struct()}, err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xa629eb7f7066fae3, s.Struct)
	return str
}

func (s Node) Which() Node_Which {
	return Node_Which(s.Struct.Uint16(8))
}
func (s Node) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Node) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Node) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Node) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Node) TreeHash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Node) HasTreeHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Node) SetTreeHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

func (s Node) ModTime() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s Node) HasModTime() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Node) ModTimeBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s Node) SetModTime(v string) error {
	return s.Struct.SetText(2, v)
}

func (s Node) Inode() uint64 {
	return s.Struct.Uint64(0)
}

func (s Node) SetInode(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Node) ContentHash() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Node) HasContentHash() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetContentHash(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Node) User() (string, error) {
	p, err := s.Struct.Ptr(4)
	return p.Text(), err
}

func (s Node) HasUser() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Node) UserBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return p.TextBytes(), err
}

func (s Node) SetUser(v string) error {
	return s.Struct.SetText(4, v)
}

func (s Node) Commit() (Commit, error) {
	if s.Struct.Uint16(8) != 0 {
		panic("Which() != commit")
	}
	p, err := s.Struct.Ptr(5)
	return Commit{Struct: p.Struct()}, err
}

func (s Node) HasCommit() bool {
	if s.Struct.Uint16(8) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetCommit(v Commit) error {
	s.Struct.SetUint16(8, 0)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Node) NewCommit() (Commit, error) {
	s.Struct.SetUint16(8, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Directory() (Directory, error) {
	if s.Struct.Uint16(8) != 1 {
		panic("Which() != directory")
	}
	p, err := s.Struct.Ptr(5)
	return Directory{Struct: p.Struct()}, err
}

func (s Node) HasDirectory() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetDirectory(v Directory) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Node) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) File() (File, error) {
	if s.Struct.Uint16(8) != 2 {
		panic("Which() != file")
	}
	p, err := s.Struct.Ptr(5)
	return File{Struct: p.Struct()}, err
}

func (s Node) HasFile() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetFile(v File) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Node) NewFile() (File, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Ghost() (Ghost, error) {
	if s.Struct.Uint16(8) != 3 {
		panic("Which() != ghost")
	}
	p, err := s.Struct.Ptr(5)
	return Ghost{Struct: p.Struct()}, err
}

func (s Node) HasGhost() bool {
	if s.Struct.Uint16(8) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Node) SetGhost(v Ghost) error {
	s.Struct.SetUint16(8, 3)
	return s.Struct.SetPtr(5, v.Struct.ToPtr())
}

// NewGhost sets the ghost field to a newly
// allocated Ghost struct, preferring placement in s's segment.
func (s Node) NewGhost() (Ghost, error) {
	s.Struct.SetUint16(8, 3)
	ss, err := NewGhost(s.Struct.Segment())
	if err != nil {
		return Ghost{}, err
	}
	err = s.Struct.SetPtr(5, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) BackendHash() ([]byte, error) {
	p, err := s.Struct.Ptr(6)
	return []byte(p.Data()), err
}

func (s Node) HasBackendHash() bool {
	p, err := s.Struct.Ptr(6)
	return p.IsValid() || err != nil
}

func (s Node) SetBackendHash(v []byte) error {
	return s.Struct.SetData(6, v)
}

// Node_List is a list of Node.
type Node_List struct{ capnp.List }

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7}, sz)
	return Node_List{l}, err
}

func (s Node_List) At(i int) Node { return Node{s.List.Struct(i)} }

func (s Node_List) Set(i int, v Node) error { return s.List.SetStruct(i, v.Struct) }

func (s Node_List) String() string {
	str, _ := text.MarshalList(0xa629eb7f7066fae3, s.List)
	return str
}

// Node_Promise is a wrapper for a Node promised by a client call.
type Node_Promise struct{ *capnp.Pipeline }

func (p Node_Promise) Struct() (Node, error) {
	s, err := p.Pipeline.Struct()
	return Node{s}, err
}

func (p Node_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

func (p Node_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

func (p Node_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

func (p Node_Promise) Ghost() Ghost_Promise {
	return Ghost_Promise{Pipeline: p.Pipeline.GetPipeline(5)}
}

const schema_9195d073cb5c5953 = "x\xda\xb4V\xefo\x14U\x17>\xcf\xbd\xb3\x9d-\x81" +
	"ww\xdf)\x09/\xa1\xec\x0d\x81\xa4\x90\x16Z\x967" +
	"B\x83\x81B\x91R+\xe9e!\x02\x01\x93a\xf7v" +
	"g\xc2\xeeL\x9d\x19,%\x1a\xd0@\x02J\x0dDH" +
	"$i#\x9a\xe2\x8fD\xa2\xff\x80\xf1G\x821\xfaE" +
	"\xfd\xa0\x89\xdfP\x13\x8d\x1a?\x1b#\x8c\xb9\xfb\xb34" +
	"U\x88\x89\xdfv\x9es\xe6\xde\xe7<\xe7\x9cg\xb6\xf7" +
	"\x17\xb6\x9d\xf5%|F$W$\xda\xe2\x9f\xfe;\xfd" +
	"\xe3\xd7]\x9f\x9c!\xb9\x12,\xce\x1f:\xf2Y\xf8\xf9" +
	"\xd5\xcb\xb4\x8b\x99\x1cF\xae\x13\xab`\xf5\xc0\xb4z\x90" +
	"\xcd\xb9\xc8\x82\x10\xcfd\x1f\x9dx\xea\xd7\xa5/Pf" +
	"%Z/$\x98I\x94;\xc7\xfaa]e\xa6u\x95" +
	"e\xad\x0f\xd9\x04!~\xe7\xe8~\xefc\xeb\xfa\x94\xbe" +
	"`n~\x9b\xce\xef\xe4\xeb`\xf5p\xd3\xea\xe1\xd9\xdc" +
	"Q\xfe\xb8>\xff@\xdf\x85\x87\x1e\xde\xf2\xc6\x8b\xf3\x18" +
	"\xd5.\x982\x96\xc3\x9a1Lk\xc6\xc8Z\xb7\x8c\x1f" +
	"\x08\xf1w\xbf\x8f\x8d\x9f\xfey\xed\xeb\xf3+0M\x03" +
	"Fn&\xb1\x1c\xd6\xcd\x84i\xddLds\xb7u\xdd" +
	"\x88g\xbf\x1f\xf9&5\xfb\xdb\xfb$\xd7`\x0e\xc1\xa5" +
	"m&\x88rn\xf20\x08\xd6\x89\xa4f\x8f\xe9\xe7\xca" +
	"\xbd\x87F\xbe\x9dO\x86k2_$w\xc0\xba\x9d4" +
	"\xad\xdb\xc9l\xee\x7f\xedUu\x0av4\x16n\xf0|" +
	"^T\xe1\x86\x82=\xee\x8do\xf0\xfc\xa2\x0a\xd7W\x7f" +
	"\xf7\xefvL?\x8cF\x01i\x80\xc5O\xbc\xf4\x8a|" +
	"\xef\xab\xe7o\x914\x18\x06\xba\x81\xc5D}\xf8\x12\xf1" +
	"n\xc7\x0f#\xe1zmE\xb7`G*\x14\x91cG" +
	"\xc2\x16\x05\x15D\xb6\xeb\x09}\xa4\x98\xb0CaG\"" +
	"r\xdcP\x8c\xdb\x91#|\xaf\x00E$;\xb8Ad" +
	"\x80(\xf3\xcca\"\xf94\x87<\xcf\x00t@c\xe7" +
	"\xf6\x11\xc9\xb3\x1c\xf2\x12C'\x8bct\x80\x11e\xa6" +
	"\xfa\x89\xe4y\x0ey\x85\xa1\x93\xdf\xd50'\xca\\\xd6" +
	"\xd9\x978\xe44C\xa7qG\xc3\x06Q\xe6\xda:\"" +
	"y\x85C^g\x88K\x9a\xed\x1e\xcf'^Th'" +
	"\x86v\xaa\x83\xa3vDp\xb0\x98\x18\x16\x13\xb6\x15\xfc" +
	"J\xc5\x8d\x90niN@\x9a\x10\x17\xdd@\x15\"?" +
	" L\"\xdd\x12\xbd\x16M\x8d\xb9e\x85tk0\xea" +
	"/\xddG\xeaAw[\xb0\xcb\x8b\x82\xc9\x85\xd5^Q" +
	"U;\x83O\xe3\x01\x11\xba^\xa9\xac\x98h\xd0\x98\x14" +
	"J\xbfH\x90\xc9\xa6\x94ku\xc5\xab9d/C\xa6" +
	"\xa1e\x8f\x06\xbb8\xe4&\x86\x94gWT\xa3\xd4\x94" +
	"c\x87\x0e\x96\x10\xc3\x92\xfb3\xdd\xe9\xa7\xb4.\x0b\xf3" +
	"\x14\xf5\xa9X\x85xgU>\xe1\xf2P\xd8\"T\x91" +
	"\xf0\xc7D\xc1\xb1\xbd\x92\x1e\x10_x\xbeYT!\x91" +
	"\\\xd6$}mG\xabMM\xd23\xba\xd3/s\xc8" +
	"Y\x86\x0cc\xb5\xf6\xbf\xaa\xc1i\x0e\xf9&C\x86\xf3" +
	"Z\xf3o\xe8\xf2\xaes\xc8\xb7\x19`\xd4:\xff\xd6F" +
	"\"9\xcb!\xdfe@\x02s\xb6)ss#\xb1\xd3" +
	"\x15\x15\x86v\xa9)\xc46\xfbD\xe4\xf8A\xf3q\xdc" +
	"\x0e\x94\x175\x94I\x05\xbe\xdf|\xc8\xba^Q\x9dD" +
	"\x82\x18\x12\x84lE\x05%u?\xe9\x1eqyY-" +
	",\xdc\xb2z\x83?\x8a\x07DY\xd9c\xc2czk" +
	"\\OD\x8e\x12\x8f\x0d\x0e\xec&\"\x99nje\xeb" +
	"b\x8fpHg\x8eVJ/P\x91C\x8e3\xa0." +
	"UEK\xe5p\xc8HKU\xdf\x93'W\x11\xc92" +
	"\x87<\xc9\x90\x0a\xddS\xadE(\xd8\x05G\x15\xf3." +
	"\xf1S\xaaQ\\C\x86\xba*\xe6q5\xf9\xa0\xc3\xb2" +
	"W\x07\x16\xaexu}T\x86\x11\xef\xad\x96\x1a\x0a\xc3" +
	"\xaeyE\xbd\xea\x8a\x0a\x8e\x97\x95(\xda%=;\xc7" +
	"\x02\xb7D\x90\xdd\x0d\x09\xac5XG\x94\x17\xe0\xc8w" +
	"\xa3\xa5\x82\xb5\x16\xc3D\xf9.\x8doBkh\xac>" +
	"\xec \xcawk|3\x18P\x1b\x1b\xeb\xff\xd8H\x94" +
	"\xef\xd5\xf0V\x9dn\xf0\xea\xe8X[p\x8c(\xbfY" +
	"\xe3\x83\x1aO\x18\x1dH\x10Y\x03\xd5k\xb7j|\x08" +
	"\x0c\x9dmq\x9c\xe8@\x1b\x91\xb5\x0b\xfdD\xf9\xed:" +
	"2\xa2#\xe6]\x1d1\x89\xac=\xd8G\x94\x1f\xd2\x91" +
	"\xfd:\x92\xbc\xa3#I\"KVO\x1b\xd1\x91\x83:" +
	"\xd2\xfe\x87\x8e\xb4\x13Y\x07\xaa\xbcFu\xe4\x88\xbe\x7f" +
	"Q[\x07\x16\x11Y\x87\xaa\xbc\x0ej\xbc\x88y\x8b\x1c" +
	"G\x81RCv\xe8\x10Q\xa3E\xa7+~q\xbf\xdb" +
	"\xca\xc9\xbaZ\xe3V\xc3}/R^4D\xe6\x1c\x0f" +
	"H\x9d\x08U\xf0\xef\x18a\xb6j\xb5H\xb7\xbe\xe5\xf5" +
	"\xc3\x8e\xd9\x85\xe3\xca+\xdeK\xa49_\xc6_\x99\x91" +
	"\xa6\xb6\xbe\xa2\x02^R\xda\xff\xd2\xb5.\xcd3\xc0Z" +
	"\x83\xee5\xc0\x097rZ\x06\xa8\xec\xe2\x83\xde9\xd8" +
	"\xf0]Zx\xb0\xbb\xea\x83\xfd\x1a\xe2FjbRh" +
	"\x9dm\xd7\x0b\x85\xef)\xe1\x07\xa2\xe2\x07\xaai\xe1\xae" +
	"\x0a56\xe6\x9a\xe5\xaa'\xce\xf9&j\xca'9\xe4" +
	"\xd99{\xfe\xac\xde\xf33\x1c\xf2bk\xcf/\xf4\xb7" +
	">\x94\xcd=\x9f\x1a&\x92\x17\xeb>i\xb0\x9a'\xde" +
	"\x18\xae{\xe2\x07\xff`\xf9\xe3\x82\xe3\x96\x8b\x81\xf2\xf4" +
	"\x84\xfd\x870\xca\x81t\xeb_\x16A\x83\x8d\xa1\x0a\xff" +
	".\xe9\xcf\x00\x00\x00\xff\xff\xfe\xabU\xc9"

func init() {
	schemas.Register(schema_9195d073cb5c5953,
		0x80c828d7e89c12ea,
		0x8b15ee76774b1f9d,
		0x8da013c66e545daf,
		0x8ea7393d37893155,
		0xa629eb7f7066fae3,
		0xbff8a40fda4ce4a4,
		0xe24c59306c829c01)
}
